<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>–ù–∞–≤—ñ–≥–∞—Ü—ñ—è –º–∞—Ä—à—Ä—É—Ç–æ–º</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    :root { --card:#fff; --line:#e5e7eb; --muted:#6b7280; --accent:#2563eb; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #map { position:fixed; inset:0; }
    .topbar { position:fixed; left:0; right:0; top:0; height:64px; display:flex; align-items:center; gap:12px; padding:8px 12px; background:rgba(255,255,255,.85); backdrop-filter: blur(8px); box-shadow:0 1px 0 var(--line); z-index:10; }
    .title { font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .stats { display:flex; gap:8px; font-size:14px; color:#111; }
    .pill { background:#f3f4f6; border:1px solid var(--line); padding:4px 8px; border-radius:999px; }
    .controls { margin-left:auto; display:flex; gap:8px; }
    button { height:40px; padding:0 12px; border-radius:10px; border:1px solid var(--line); background:var(--card); cursor:pointer; font-weight:600; }
    .primary { background:var(--accent); color:#fff; border-color:#1d4ed8; }
    .fab { position:fixed; right:12px; bottom:12px; z-index:10; display:flex; flex-direction:column; gap:8px; }
    .fab button { background:#fff; width:48px; height:48px; border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.15); border:1px solid var(--line); }
    .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#111; color:#fff; padding:10px 14px; border-radius:10px; display:none; z-index:20; }
    .notice{
      position:fixed; left:12px; right:12px;
      bottom:calc(env(safe-area-inset-bottom) + 12px);
      background:rgba(17,24,39,.9); color:#fff;
      padding:8px 12px; border-radius:12px;
      font-size:13px; line-height:1.35; display:none; z-index:20;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <div class="title" id="routeTitle">–ù–∞–≤—ñ–≥–∞—Ü—ñ—è</div>
    <div class="stats">
      <div class="pill" id="statDistance">‚Äî –∫–º</div>
      <div class="pill" id="statEta">ETA ‚Äî</div>
      <div class="pill" id="statMode">driving</div>
    </div>
    <div class="controls">
      <button id="btnStart" class="primary">–°—Ç–∞—Ä—Ç</button>
      <button id="btnStop">–°—Ç–æ–ø</button>
      <button id="btnShare">–ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è</button>
    </div>
  </div>

  <div class="fab">
    <button id="btnRecenter" title="–°—Ç–µ–∂–µ–Ω–Ω—è: —É–≤—ñ–º–∫–Ω–µ–Ω–æ">üîí</button>
  </div>

  <div class="toast" id="toast">–°–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ</div>
  <div class="notice" id="notice">–î–ª—è –≥–æ–ª–æ—Å–æ–≤–∏—Ö –ø—ñ–¥–∫–∞–∑–æ–∫ –∑–∞–ª–∏—à–∞–π —Ü—é —Å—Ç–æ—Ä—ñ–Ω–∫—É –≤—ñ–¥–∫—Ä–∏—Ç–æ—é –Ω–∞ –µ–∫—Ä–∞–Ω—ñ. –£ —Ñ–æ–Ω–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ –±—Ä–∞—É–∑–µ—Ä –º–æ–∂–µ –∑—É–ø–∏–Ω—è—Ç–∏ GPS/–∑–≤—É–∫.</div>

<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const MAPBOX_TOKEN = qs.get('token') || window.MAPBOX_TOKEN || '';
  const PROFILE = qs.get('profile') || 'driving';
  const SRC_B64 = qs.get('src');
  const AUTO_START = qs.get('autostart') === '1';

  // === Track-up –∫–∞–º–µ—Ä–∞ ===
  const NAV_PITCH_DEG   = 60;
  const NAV_OFFSET_PX   = 180;
  const NAV_MIN_ZOOM    = 13;
  const CAMERA_DURATION = 350;

  // === Snapping/–ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –º—ñ–∂ –º–∞—Ä—à—Ä—É—Ç/–ª—ñ–Ω—ñ–π–∫–∏/–≤—ñ–ª—å–Ω–æ ===
  const SNAP_SWITCH_KM   = 0.25; // –∫–æ–ª–∏ —Ç–∞–∫ –±–ª–∏–∑—å–∫–æ –¥–æ –ø–æ—á–∞—Ç–∫—É/–∫—ñ–Ω—Ü—è –º–∞—Ä—à—Ä—É—Ç—É ‚Äî –≤—ñ–¥–¥–∞—î–º–æ –ø–µ—Ä–µ–≤–∞–≥—É –ª—ñ–Ω—ñ–π—Ü—ñ
  const SNAP_TOL_ROUTE_M = 60;   // –¥–æ–ø—É—Å–∫ –ø—Ä–∏–ª–∏–ø–∞–Ω–Ω—è –¥–æ –º–∞—Ä—à—Ä—É—Ç—É
  const SNAP_TOL_RULER_M = 80;   // –¥–æ–ø—É—Å–∫ –ø—Ä–∏–ª–∏–ø–∞–Ω–Ω—è –¥–æ –ª—ñ–Ω—ñ–π–∫–∏

  // === GPS —Ñ—ñ–ª—å—Ç—Ä–∏ ===
  const GPS_ACCURACY_MAX = 50;
  const SMOOTH_ALPHA_POS = 0.5;
  const SMOOTH_ALPHA_HD  = 0.6;

  // === –®–≤–∏–¥–∫—ñ—Å—Ç—å/–ø—ñ–¥–∫–∞–∑–∫–∏ ===
  const SPEED_ALPHA = 0.5;
  const MAX_SPEED_MPS = 90/3.6;
  const SPEAK_LOOKAHEAD_SEC = 8;
  const SPEAK_MIN_DIST = 60;
  const SPEAK_MAX_DIST = 800;
  const SPEAK_NOW_DIST = 25;

  function b64decodeUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function b64encodeUtf8(objOrString){
    const s = typeof objOrString === 'string' ? objOrString : JSON.stringify(objOrString);
    const bytes = new TextEncoder().encode(s);
    let bin = '';
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function toArrayPoints(arr){
    if (!Array.isArray(arr)) return [];
    if (arr.length && typeof arr[0]==='object' && arr[0]!==null && 'lng' in arr[0]) {
      return arr.map(p=>[p.lng,p.lat]);
    }
    return arr;
  }

  if (!MAPBOX_TOKEN){
    alert('–í—ñ–¥—Å—É—Ç–Ω—ñ–π Mapbox token. –ü–µ—Ä–µ–¥–∞–π ?token=... —É –ø–æ—Å–∏–ª–∞–Ω–Ω—ñ.');
  }
  mapboxgl.accessToken = MAPBOX_TOKEN;

  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [30.523, 50.45],
    zoom: 12,
    pitch: 45,
    attributionControl: true
  });
  map.addControl(new mapboxgl.NavigationControl({visualizePitch:true}), 'bottom-left');

  // –£–ö–†–ê–á–ù–°–¨–ö–Ü –ü–Ü–î–ü–ò–°–ò
  function applyUkrainianLabels(){
    const style = map.getStyle();
    if (!style || !style.layers) return;
    const ukExpr = ['coalesce',
      ['get','name_uk'], ['get','name:uk'], ['get','name_ua'], ['get','name:ua'], ['get','name_local'], ['get','name']
    ];
    style.layers.forEach(l=>{
      if (l.type === 'symbol') {
        const has = map.getLayoutProperty(l.id, 'text-field') !== undefined;
        if (has) { try { map.setLayoutProperty(l.id, 'text-field', ukExpr); } catch(_){ } }
      }
    });
  }

  // UI
  document.getElementById('statMode').textContent = PROFILE;
  const $title = document.getElementById('routeTitle');
  const $dist = document.getElementById('statDistance');
  const $eta = document.getElementById('statEta');
  const $toast = document.getElementById('toast');
  const $notice = document.getElementById('notice');
  const $recenter = document.getElementById('btnRecenter');

  // –ù–∞–≤—ñ–≥–∞—Ü—ñ–π–Ω—ñ –¥–∞–Ω—ñ
  let routeGeoJSON = null, routeLengthKm = 0;
  let steps = [];
  let totalDistance = 0, totalDuration = 0;

  // –õ—ñ–Ω—ñ–π–∫–∏
  let startRuler = [], endRuler = [];
  let startLine = null, endLine = null;

  // –°—Ç–∞–Ω
  let watchId = null;
  let userMarker = null;
  let lastUserPos = null;
  let filteredPos = null, filteredHeading = null;
  let lastTs = null, lastSpeedPos = null, speedMps = 0;
  let followHard = true; // üîí
  let autoCenter = true;
  let spoken = { idx: -1, early: false, now: false };

  // –ì–æ–ª–æ—Å (—É–∫—Ä.)
  let uaVoice = null;
  function pickUkrainianVoice() {
    const voices = window.speechSynthesis?.getVoices?.() || [];
    const ua = voices.filter(v => (v.lang || '').toLowerCase().startsWith('uk'));
    uaVoice = ua.find(v => /google|microsoft|apple/i.test(v.name)) || ua[0] || null;
  }
  if ('speechSynthesis' in window) {
    pickUkrainianVoice();
    window.speechSynthesis.onvoiceschanged = pickUkrainianVoice;
  }
  function speak(text){
    try{
      if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'uk-UA';
      if (uaVoice) u.voice = uaVoice;
      window.speechSynthesis.speak(u);
    }catch(e){}
  }

  function showToast(msg){ $toast.textContent = msg; $toast.style.display='block'; setTimeout(()=>{$toast.style.display='none'}, 1300); }
  function metersToKM(m){ return (m/1000).toFixed(1); }
  function secondsToETA(s){
    const dt = new Date(Date.now() + s*1000);
    const hh = String(dt.getHours()).padStart(2,'0');
    const mm = String(dt.getMinutes()).padStart(2,'0');
    return `${hh}:${mm}`;
  }

  async function loadRouteData(){
    if (!SRC_B64) throw new Error('–ù–µ –ø–µ—Ä–µ–¥–∞–Ω–æ –º–∞—Ä—à—Ä—É—Ç. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π ?src=...');
    const json = JSON.parse(b64decodeUtf8(SRC_B64));
    return {
      name: json.name || '–ú–∞—Ä—à—Ä—É—Ç',
      points: toArrayPoints(json.points),
      startRuler: toArrayPoints(json.startRuler || []),
      endRuler: toArrayPoints(json.endRuler || [])
    };
  }

  function preprocessSteps(routeLine, rawSteps){
    routeLengthKm = turf.length(routeLine, {units:'kilometers'});
    const out = rawSteps.map((s) => {
      const manCoord = (s.maneuver && Array.isArray(s.maneuver.location))
        ? s.maneuver.location
        : s.geometry.coordinates.at(-1);
      const snap = turf.nearestPointOnLine(routeLine, manCoord, {units:'kilometers'});
      const locKm = (snap.properties && typeof snap.properties.location === 'number')
        ? snap.properties.location
        : 0;
      s._manCoord = manCoord;
      s._locKm = locKm;
      return s;
    });
    out.sort((a,b)=>a._locKm - b._locKm);
    return out;
  }

  async function fetchDirections(points){
    const coords = points.map(p => p.join(',')).join(';');
    const url = `https://api.mapbox.com/directions/v5/mapbox/${PROFILE}/${coords}?alternatives=false&geometries=geojson&overview=full&steps=true&language=uk&voice_units=metric&access_token=${MAPBOX_TOKEN}`;
    const res = await fetch(url);
    if (!res.ok){
      const text = await res.text().catch(()=> '');
      console.error('Directions API error', res.status, text);
      throw new Error(`Directions API error (${res.status})`);
    }
    const json = await res.json();
    if (!json.routes || !json.routes[0]) throw new Error('–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –ø–æ–±—É–¥–æ–≤–∞–Ω–æ');
    const r = json.routes[0];
    routeGeoJSON = { type:'Feature', geometry:r.geometry, properties:{} };
    totalDistance = r.distance;
    totalDuration = r.duration;
    $dist.textContent = `${metersToKM(totalDistance)} –∫–º`;
    $eta.textContent = `ETA ${secondsToETA(totalDuration)}`;
    const rawSteps = r.legs.flatMap(l=>l.steps);
    steps = preprocessSteps(routeGeoJSON, rawSteps);
    return routeGeoJSON;
  }

  function addRouteToMap(){
    if (!routeGeoJSON) return;
    if (map.getSource('route')){
      map.getSource('route').setData(routeGeoJSON);
    } else {
      map.addSource('route', { type:'geojson', data: routeGeoJSON });
      map.addLayer({ id:'route-line', type:'line', source:'route', paint:{ 'line-width':6, 'line-color':'#1d4ed8' } });
    }
    const bbox = turf.bbox(routeGeoJSON);
    map.fitBounds(bbox, { padding:{top:80, right:20, bottom:20, left:20} });
  }

  function buildAuxLines(){
    startLine = (startRuler && startRuler.length>1) ? { type:'Feature', geometry:{type:'LineString', coordinates:startRuler} } : null;
    endLine   = (endRuler && endRuler.length>1)     ? { type:'Feature', geometry:{type:'LineString', coordinates:endRuler} }   : null;
  }
  function addAuxLines(){
    // start ruler
    if (startLine){
      if (!map.getSource('ruler-start')){
        map.addSource('ruler-start', { type:'geojson', data: startLine });
        map.addLayer({ id:'ruler-start-line', type:'line', source:'ruler-start',
          layout:{ 'line-cap':'round', 'line-join':'round' },
          paint:{ 'line-width':4, 'line-color':'#22c55e', 'line-dasharray':[1.5, 1.5] }
        });
      } else { map.getSource('ruler-start').setData(startLine); }
    }
    // end ruler
    if (endLine){
      if (!map.getSource('ruler-end')){
        map.addSource('ruler-end', { type:'geojson', data: endLine });
        map.addLayer({ id:'ruler-end-line', type:'line', source:'ruler-end',
          layout:{ 'line-cap':'round', 'line-join':'round' },
          paint:{ 'line-width':4, 'line-color':'#f59e0b', 'line-dasharray':[1.5, 1.5] }
        });
      } else { map.getSource('ruler-end').setData(endLine); }
    }
  }

  function ensureUserMarker(lng, lat){
    if (!userMarker){
      const el = document.createElement('div');
      el.style.width='18px'; el.style.height='18px'; el.style.borderRadius='50%';
      el.style.background='#10b981'; el.style.border='2px solid #fff'; el.style.boxShadow='0 0 0 2px rgba(16,185,129,.4)';
      userMarker = new mapboxgl.Marker({element:el, rotationAlignment:'map'}).setLngLat([lng, lat]).addTo(map);
    } else {
      userMarker.setLngLat([lng, lat]);
    }
  }
  function computeHeading(prev, curr){
    if (!prev) return null;
    const bearing = turf.bearing(turf.point(prev), turf.point(curr));
    return (bearing+360)%360;
  }
  function updateCamera(centerLL, bearingDeg){
    if (!centerLL) return;
    const opts = {
      center: centerLL,
      duration: CAMERA_DURATION,
      essential: true,
      bearing: (bearingDeg!=null && !Number.isNaN(bearingDeg)) ? bearingDeg : map.getBearing(),
      pitch: NAV_PITCH_DEG,
      offset: [0, NAV_OFFSET_PX]
    };
    if (map.getZoom() < NAV_MIN_ZOOM) opts.zoom = NAV_MIN_ZOOM;
    map.easeTo(opts);
  }

  function setFollowUI(){
    if (followHard){
      $recenter.textContent = 'üîí';
      $recenter.title = '–°—Ç–µ–∂–µ–Ω–Ω—è: —É–≤—ñ–º–∫–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –¥–æ–∑–≤–æ–ª–∏—Ç–∏ –≤—ñ–ª—å–Ω–∏–π –ø–µ—Ä–µ–≥–ª—è–¥ –∫–∞—Ä—Ç–∏';
    } else {
      $recenter.textContent = 'üìç';
      $recenter.title = '–°—Ç–µ–∂–µ–Ω–Ω—è: –≤–∏–º–∫–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –∑–Ω–æ–≤—É —É–≤—ñ–º–∫–Ω—É—Ç–∏';
    }
  }
  setFollowUI();

  map.on('dragstart',   ()=> { if (!followHard) autoCenter = false; });
  map.on('rotatestart', ()=> { if (!followHard) autoCenter = false; });
  map.on('pitchstart',  ()=> { if (!followHard) autoCenter = false; });

  $recenter.onclick = ()=>{
    followHard = !followHard;
    autoCenter = followHard;
    setFollowUI();
    if (followHard && lastUserPos) updateCamera(lastUserPos, filteredHeading);
  };

  // === –í–∏–±—ñ—Ä –∞–∫—Ç–∏–≤–Ω–æ—ó –ª—ñ–Ω—ñ—ó –¥–ª—è "–ø—Ä–∏–ª–∏–ø–∞–Ω–Ω—è" ===
  // –ü–æ–≤–µ—Ä—Ç–∞—î { id: 'route'|'start'|'end'|'free', coord:[lng,lat], locKm:number }
  function chooseSnap(raw){
    let locKm = 0;
    let phase = 'route';
    let routeP = null, routeDist = Infinity;
    if (routeGeoJSON){
      routeP = turf.nearestPointOnLine(routeGeoJSON, raw, {units:'meters'});
      routeDist = (routeP.properties.distance ?? routeP.properties.dist ?? Infinity);
      locKm = (routeP.properties.location ?? 0);
      const nearStart = (locKm < SNAP_SWITCH_KM);
      const nearEnd   = (routeLengthKm - locKm < SNAP_SWITCH_KM);
      if (nearStart && startLine) phase = 'start';
      else if (nearEnd && endLine) phase = 'end';
      else phase = 'route';
    }

    let startP = null, startDist = Infinity;
    if (startLine){
      startP = turf.nearestPointOnLine(startLine, raw, {units:'meters'});
      startDist = (startP.properties.distance ?? startP.properties.dist ?? Infinity);
    }
    let endP = null, endDist = Infinity;
    if (endLine){
      endP = turf.nearestPointOnLine(endLine, raw, {units:'meters'});
      endDist = (endP.properties.distance ?? endP.properties.dist ?? Infinity);
    }

    // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç: —Ñ–∞–∑–∞ -> –±–ª–∏–∑—å–∫—ñ—Å—Ç—å -> –º–∞—Ä—à—Ä—É—Ç
    if (phase==='start' && startLine && startDist <= SNAP_TOL_RULER_M) return { id:'start', coord:startP.geometry.coordinates, locKm };
    if (phase==='end'   && endLine   && endDist   <= SNAP_TOL_RULER_M) return { id:'end',   coord:endP.geometry.coordinates,   locKm };

    if (routeGeoJSON && routeDist <= SNAP_TOL_ROUTE_M) return { id:'route', coord: routeP.geometry.coordinates, locKm };

    // –î–∞–ª–µ–∫–æ –≤—ñ–¥ –º–∞—Ä—à—Ä—É—Ç—É ‚Äî —è–∫—â–æ –±–ª–∏–∑—å–∫–æ –¥–æ —è–∫–æ—ó—Å—å –ª—ñ–Ω—ñ–π–∫–∏, –ø—Ä–∏–ª–∏–ø–Ω–µ–º–æ –¥–æ –Ω–µ—ó
    if (startLine && startDist < endDist && startDist <= SNAP_TOL_RULER_M) return { id:'start', coord:startP.geometry.coordinates, locKm };
    if (endLine   && endDist   <= SNAP_TOL_RULER_M) return { id:'end',   coord:endP.geometry.coordinates,   locKm };

    // –Ü–Ω–∞–∫—à–µ ‚Äî –≤—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º
    return { id:'free', coord: raw, locKm };
  }

  function stepToSpeech(step, mode='soon', overrideMeters=null){
    const man = step.maneuver || {};
    let text = man.instruction || '';
    text = text.replace(/Turn right/i, '–ü–æ–≤–µ—Ä–Ω—ñ—Ç—å –ø—Ä–∞–≤–æ—Ä—É—á')
               .replace(/Turn left/i, '–ü–æ–≤–µ—Ä–Ω—ñ—Ç—å –ª—ñ–≤–æ—Ä—É—á')
               .replace(/Continue/i, '–†—É—Ö–∞–π—Ç–µ—Å—å –ø—Ä—è–º–æ')
               .replace(/At the roundabout/i, '–ù–∞ –∫–æ–ª—ñ')
               .replace(/Take the exit/i, '–ó º—ó–∂–¥–∂–∞–π—Ç–µ –Ω–∞ –≤–∏—ó–∑–¥');
    if (mode === 'now') return '–ó–∞—Ä–∞–∑: ' + text.replace(/\. –ó–∞ .+$/,'');
    const d = Math.round(overrideMeters ?? (step.distance||0));
    const add = d < 1000 ? `${d} –º` : `${(d/1000).toFixed(1)} –∫–º`;
    if (!/–º|km|–∫–º/.test(text)) return `${text}. –ó–∞ ${add}`;
    return text;
  }
  function resetSpokenFor(idx){ spoken = { idx, early:false, now:false }; }

  // –û—Å–Ω–æ–≤–Ω–∏–π –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–∑–∏—Ü—ñ—ó
  function onPosition(pos){
    if (Number.isFinite(pos.coords.accuracy) && pos.coords.accuracy > GPS_ACCURACY_MAX) return;

    const raw = [pos.coords.longitude, pos.coords.latitude];

    // –û–±–∏—Ä–∞—î–º–æ –∞–∫—Ç–∏–≤–Ω—É –ª—ñ–Ω—ñ—é (–º–∞—Ä—à—Ä—É—Ç/–ª—ñ–Ω—ñ–π–∫–∞/–≤—ñ–ª—å–Ω–æ)
    const snap = chooseSnap(raw);
    let onLine = snap.coord; // –∫—É–¥–∏ "—Ç—è–≥–Ω–µ–º–æ" —Ñ—ñ–ª—å—Ç—Ä
    const activeId = snap.id;
    const userLocKm = snap.locKm || 0;

    // –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    filteredPos = filteredPos
      ? [ filteredPos[0] + (onLine[0] - filteredPos[0]) * SMOOTH_ALPHA_POS,
          filteredPos[1] + (onLine[1] - filteredPos[1]) * SMOOTH_ALPHA_POS ]
      : onLine;

    // –ö—É—Ä—Å: –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç GPS heading, —ñ–Ω–∞–∫—à–µ ‚Äî –∑ —Ç—Ä–∞—î–∫—Ç–æ—Ä—ñ—ó
    const gpsHeading = Number.isFinite(pos.coords.heading) ? pos.coords.heading : null;
    const headingInstant = gpsHeading != null
      ? gpsHeading
      : (lastUserPos ? computeHeading(lastUserPos, filteredPos) : null);
    if (headingInstant != null){
      filteredHeading = (filteredHeading == null)
        ? headingInstant
        : filteredHeading + (headingInstant - filteredHeading) * SMOOTH_ALPHA_HD;
    }
    lastUserPos = filteredPos;

    // –û—Ü—ñ–Ω–∫–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ
    const ts = (typeof pos.timestamp === 'number' ? pos.timestamp : Date.now());
    if (lastSpeedPos && lastTs){
      const dM = turf.distance(turf.point(lastSpeedPos), turf.point(filteredPos), {units:'kilometers'})*1000;
      const dt = Math.max(0.2, (ts - lastTs)/1000);
      const inst = Math.min(dM/dt, MAX_SPEED_MPS);
      speedMps = (1 - SPEED_ALPHA)*speedMps + SPEED_ALPHA*inst;
    }
    lastSpeedPos = filteredPos;
    lastTs = ts;

    // –ú–∞—Ä–∫–µ—Ä + –∫–∞–º–µ—Ä–∞
    ensureUserMarker(filteredPos[0], filteredPos[1]);
    if (followHard || autoCenter) updateCamera(filteredPos, filteredHeading);

    // –ó–∞–ª–∏—à–æ–∫/ETA ‚Äî –±–∞–∑–æ–≤–æ –ø–æ –º–∞—Ä—à—Ä—É—Ç—É (–Ω–∞ –ª—ñ–Ω—ñ–π–∫–∞—Ö –±—É–¥–µ –ø—Ä–∏–±–ª–∏–∑–Ω–æ)
    if (routeGeoJSON){
      const remain = Math.max(0, (routeLengthKm - userLocKm) * 1000);
      $dist.textContent = `${(remain/1000).toFixed(1)} –∫–º`;
      const etaSec = (remain / (totalDistance/1000)) * totalDuration;
      $eta.textContent = `ETA ${secondsToETA(etaSec)}`;
    }

    // –ì–æ–ª–æ—Å–æ–≤—ñ –ø—ñ–¥–∫–∞–∑–∫–∏ ‚Äî —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ –º–∏ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–º—É –º–∞—Ä—à—Ä—É—Ç—ñ
    if (activeId === 'route' && steps && steps.length){
      let next = null;
      for (let i = 0; i < steps.length; i++){
        const s = steps[i];
        if (s._locKm > userLocKm){
          s._index = i;
          s._metersToManeuver = Math.max(0, (s._locKm - userLocKm) * 1000);
          s._remainMeters = Math.max(0, (routeLengthKm - userLocKm) * 1000);
          next = s; break;
        }
      }
      if (next){
        const lead = Math.min(SPEAK_MAX_DIST, Math.max(SPEAK_MIN_DIST, speedMps * SPEAK_LOOKAHEAD_SEC));
        if (spoken.idx !== next._index) resetSpokenFor(next._index);
        if (!spoken.early && next._metersToManeuver <= lead && next._metersToManeuver > SPEAK_NOW_DIST){
          speak(stepToSpeech(next, 'soon', next._metersToManeuver));
          spoken.early = true;
        }
        if (!spoken.now && next._metersToManeuver <= SPEAK_NOW_DIST){
          speak(stepToSpeech(next, 'now'));
          spoken.now = true;
        }
      }
    }
  }
  function onPositionError(err){ console.warn('GPS error', err); }

  // –ö–Ω–æ–ø–∫–∏/–∂–µ—Å—Ç–∏
  document.getElementById('btnStart').onclick = startNav;
  document.getElementById('btnStop').onclick = stopNav;
  document.getElementById('btnShare').onclick = shareLink;

  let noticeTimer = null;
  function startNav(){
    if (watchId!=null) return;
    if (!navigator.geolocation){ alert('–ì–µ–æ–ª–æ–∫–∞—Ü—ñ—è –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º'); return; }
    $notice.style.display='block';
    clearTimeout(noticeTimer);
    noticeTimer = setTimeout(()=>{$notice.style.display='none';}, 4000);

    followHard = true; autoCenter = true; setFollowUI();

    watchId = navigator.geolocation.watchPosition(
      onPosition, onPositionError,
      { enableHighAccuracy:true, maximumAge:0, timeout:5000 }
    );
    speak('–ù–∞–≤—ñ–≥–∞—Ü—ñ—é —Ä–æ–∑–ø–æ—á–∞—Ç–æ');
  }
  function stopNav(){
    if (watchId!=null){
      navigator.geolocation.clearWatch(watchId);
      watchId=null;
      speak('–ù–∞–≤—ñ–≥–∞—Ü—ñ—é –∑—É–ø–∏–Ω–µ–Ω–æ');
      clearTimeout(noticeTimer);
      $notice.style.display='none';
    }
  }

  async function shareLink(){
    if (!routeGeoJSON){ showToast('–ú–∞—Ä—à—Ä—É—Ç —â–µ –Ω–µ –≥–æ—Ç–æ–≤–∏–π'); return; }
    const name = $title.textContent || '–ú–∞—Ä—à—Ä—É—Ç';
    const points = routeGeoJSON.geometry.coordinates;
    // –í–ê–ñ–õ–ò–í–û: –¥–æ–¥–∞—î–º–æ –ª—ñ–Ω—ñ–π–∫–∏ –≤ payload, —â–æ–± —ñ–Ω—à–∏–π –≤–æ–¥—ñ–π —Ç–µ–∂ –±–∞—á–∏–≤ —ñ ‚Äú–ø—Ä–∏–ª–∏–ø–∞–≤‚Äù
    const payload = { name, points, startRuler, endRuler };
    const b64 = b64encodeUtf8(payload);
    const url = `${location.origin}${location.pathname}?src=${encodeURIComponent(b64)}&profile=${PROFILE}&token=${encodeURIComponent(MAPBOX_TOKEN)}&autostart=1`;
    try{
      if (navigator.share){ await navigator.share({ title:name, url }); }
      else { await navigator.clipboard.writeText(url); showToast('–ü–æ—Å–∏–ª–∞–Ω–Ω—è —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ'); }
    }catch(e){ await navigator.clipboard.writeText(url); showToast('–ü–æ—Å–∏–ª–∞–Ω–Ω—è —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ'); }
  }

  map.on('style.load', applyUkrainianLabels);

  map.on('load', async ()=>{
    try{
      const { name, points, startRuler:SR, endRuler:ER } = await loadRouteData();
      $title.textContent = name;
      startRuler = SR || []; endRuler = ER || [];
      buildAuxLines();

      const waypoints = (points || []);
      try {
        await fetchDirections(waypoints.length ? waypoints : [startRuler[0], endRuler.at(-1)]);
      } catch (e) {
        if (String(e.message || '').includes('422') && waypoints.length > 2) {
          await fetchDirections([waypoints[0], waypoints[waypoints.length - 1]]);
        } else {
          throw e;
        }
      }

      addRouteToMap();
      addAuxLines();
      if (AUTO_START) startNav();
    }catch(e){ console.error(e); alert(e.message || e); }
  });
})();
</script>
</body>
</html>
